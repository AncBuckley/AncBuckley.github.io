import MooseMan from'./MooseMan.js';let Character=MooseMan;const canvas=document.getElementById('game');const ctx=canvas.getContext('2d');const menu=document.getElementById('menu');const help=document.getElementById('help');const gameover=document.getElementById('gameover');const startBtn=document.getElementById('startBtn');const againBtn=document.getElementById('againBtn');const menuBtn=document.getElementById('menuBtn');const pauseBtn=document.getElementById('pauseBtn');const helpBtn=document.getElementById('helpBtn');const closeHelp=document.getElementById('closeHelp');const difficulty=document.getElementById('difficulty');const categorySelect=document.getElementById('categorySelect');const modeSelect=document.getElementById('modeSelect');const gridSelect=document.getElementById('gridSelect');const levelSpan=document.getElementById('level');const scoreSpan=document.getElementById('score');const livesSpan=document.getElementById('lives');const toast=document.getElementById('toast');const catBadge=document.getElementById('categoryBadge');const levelProgress=document.getElementById('levelProgress');const rand=(min,max)=>Math.random()*(max-min)+min;const randi=(min,max)=>Math.floor(rand(min,max));const choice=arr=>arr[Math.floor(Math.random()*arr.length)];const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));const now=()=>performance.now();const shuffle=arr=>{for(let i=arr.length-1;i>0;i--){const j=randi(0,i+1);[arr[i],arr[j]]=[arr[j],arr[i]]}return arr};const easeOutCubic=t=>1-Math.pow(1-t,3);const lerp=(a,b,t)=>a+(b-a)*t;const esc=s=>String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;');const isPrime=n=>{if(n<2)return false;if(n%2===0)return n===2;const r=(Math.sqrt(n)|0);for(let i=3;i<=r;i+=2){if(n%i===0)return false}return true};let WORD_SETS={};let CATEGORIES=[];function applyCrossHints(wordSets,crossHints){if(!crossHints)return wordSets;const hasWord=(arr,w)=>arr.some(x=>x.toLowerCase()===String(w).toLowerCase());for(const[word,targets]of Object.entries(crossHints)){for(const setName of targets){wordSets[setName]=wordSets[setName]||[];if(!hasWord(wordSets[setName],word))wordSets[setName].push(word)}}return wordSets}function makeWordCategory(name,correctSet,distractFromKeys=[],labelCase='lower',forcedId,sourceKey){const normalize=s=>labelCase==='title'?String(s).replace(/\b\w/g,c=>c.toUpperCase()):labelCase==='upper'?String(s).toUpperCase():String(s);const toLower=s=>String(s).toLowerCase();const correctLower=new Set((correctSet||[]).map(toLower));const pool=[];for(const[key,arr]of Object.entries(WORD_SETS)){if(!arr)continue;if(sourceKey&&key===sourceKey)continue;pool.push(...arr)}for(const key of(distractFromKeys||[])){const arr=WORD_SETS[key];if(arr)pool.push(...arr)}const poolLower=[...new Set(pool.map(toLower))].filter(w=>!correctLower.has(w));return{id:forcedId||name.toLowerCase().replace(/\s+/g,'-'),name,type:'word',sourceKey,labelCase,generate:(W,H,countCorrect=12)=>{const total=W*H;const correctList=[...new Set((correctSet||[]).map(String))];const selectedCorrect=shuffle(correctList).slice(0,Math.min(countCorrect,total));const distractNeeded=Math.max(0,total-selectedCorrect.length);const src=poolLower.length?shuffle(poolLower):[];const distractsLower=[];for(let i=0;i<distractNeeded;i++){if(src.length===0)break;distractsLower.push(src[i%src.length])}const hydrate=wLower=>{for(const arr of Object.values(WORD_SETS)){const found=(arr||[]).find(x=>toLower(x)===wLower);if(found)return String(found)}return wLower};const distracts=distractsLower.map(hydrate);const items=[...selectedCorrect,...distracts].map(w=>({label:normalize(w),value:String(w),correct:correctLower.has(toLower(w))}));return shuffle(items)}}}function numericCategory(name,predicate,opts={}){const min=opts.min??2;const max=opts.max??99;return{id:opts.id||name.toLowerCase().replace(/\s+/g,'-'),name,type:'number',min,max,test:predicate,generate:(W,H)=>{const total=W*H;const pool=Array.from({length:max-min+1},(_,i)=>i+min);const chosen=shuffle(pool).slice(0,total);return chosen.map(n=>({label:String(n),value:n,correct:!!predicate(n)}))}}}function buildCategoriesFromJSON(json){WORD_SETS=json.wordSets||{};WORD_SETS=applyCrossHints(WORD_SETS,json.crossHints);const list=[];for(const nc of(json.numbers||[])){let predicate=()=>false;switch(nc.kind){case'even':predicate=n=>n%2===0;break;case'odd':predicate=n=>n%2!==0;break;case'prime':predicate=n=>isPrime(n);break;case'multipleOf':{const k=nc.k||1;predicate=n=>n%k===0;break}case'square':predicate=n=>Number.isInteger(Math.sqrt(n));break;case'factorsOf':{const N=nc.n||1;predicate=n=>N%n===0;break}case'greaterThan':{const T=nc.threshold??0;predicate=n=>n>T;break}case'lessThan':{const T=nc.threshold??0;predicate=n=>n<T;break}}list.push(numericCategory(nc.name,predicate,{id:nc.id,min:nc.min,max:nc.max}))}for(const wc of(json.words||[])){const set=WORD_SETS[wc.set]||[];list.push(makeWordCategory(wc.name,set,wc.distractFrom||[],wc.case||'lower',wc.id,wc.set))}return list}async function loadCategories(){const url=new URL('./categories.json',import.meta.url).toString();try{const res=await fetch(url,{cache:'no-store'});if(!res.ok)throw new Error(`HTTP ${res.status} for ${url}`);const data=await res.json();CATEGORIES=buildCategoriesFromJSON(data)}catch(err){console.error('Failed to load categories.json, using minimal fallback. URL tried:',url,err);WORD_SETS={fruits:["apple","pear","mango","plum"],mammals:["cat","dog"],colors:["red","blue"]};CATEGORIES=[numericCategory("Even Numbers",n=>n%2===0,{id:'even-numbers',min:2,max:50}),makeWordCategory("Fruits",WORD_SETS.fruits,["colors","mammals"],'lower','fruits','fruits')]}}const pickRandomCategory=excludeId=>{const choices=CATEGORIES.filter(c=>c.id!==excludeId);return choice(choices.length?choices:CATEGORIES)};const pickRandomMathCategory=excludeId=>{const nums=CATEGORIES.filter(c=>c.type==='number'&&c.id!==excludeId);return choice(nums.length?nums:CATEGORIES.filter(c=>c.type==='number'))};const computeMathNeeded=(level,base)=>Math.max(1,Math.floor(base*Math.pow(2,level-1)));const DIRS={UP:0,RIGHT:1,DOWN:2,LEFT:3};const DIR_VECT=[[0,-1],[1,0],[0,1],[-1,0]];const ENEMY_STEP_MS=3000;const TROGGLE_COLORS=['#ff3b6b','#ffb800','#00e5ff','#7cff00','#ff00e5','#ff7a00','#00ffb3','#ffd700','#00ffd0','#ff4d00'];let state={running:false,paused:false,level:1,score:0,lives:3,gridW:12,gridH:8,tile:64,category:null,items:[],correctRemaining:0,player:null,enemies:[],freezeUntil:0,invulnUntil:0,lastTime:0,mode:'classic',math:{progress:0,base:6,needed:6}};let explosions=[];let starBursts=[];let sfx=[];let catFly=null;let star=null;function resizeCanvas(){const dpr=window.devicePixelRatio||1;const rect=canvas.getBoundingClientRect();canvas.width=Math.floor(rect.width*dpr);canvas.height=Math.floor(rect.height*dpr);ctx.setTransform(dpr,0,0,dpr,0,0);state.tile=Math.floor(Math.min(rect.width/state.gridW,rect.height/state.gridH))}addEventListener('resize',resizeCanvas);function minCorrectForBoard(W,H){return Math.min(W*H,Math.max(12,state.mode==='math'?(state.math.needed||12):12))}function buildBoard(){if(!state.category){console.warn('No category yet');return}const W=state.gridW,H=s_]()*_*_]()*
