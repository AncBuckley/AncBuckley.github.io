<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MuncherJS ‚Äî Super Munchers‚Äìstyle</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --muted:#8ea0d0;
      --accent:#6de2ff;
      --accent2:#9cff6d;
      --danger:#ff6d8a;
      --warning:#ffd166;
      --good:#77ffb4;
      --tile:#141e3f;
      --tile2:#1b2753;
      --shadow:0 10px 30px rgba(0,0,0,.4);
      --radius:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background: radial-gradient(1200px 800px at 20% -10%, #142048 0%, #0b1020 45%, #070a16 100%);
      color:#e8eeff; font: 16px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      display:flex; align-items:center; justify-content:center; overflow:hidden;
    }
    #root{ width:min(1150px, 100%); padding:16px; }
    .hud{ display:flex; align-items:center; gap:12px; justify-content:space-between; flex-wrap:wrap; background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0)); border:1px solid rgba(255,255,255,.08); border-radius: var(--radius); padding:12px 16px; box-shadow: var(--shadow); }
    .hud-left{ display:flex; align-items:center; gap:12px; flex-wrap:wrap }
    .badge{ padding:6px 10px; border-radius:12px; background: rgba(255,255,255,.06); color:#cfe0ff; border:1px solid rgba(255,255,255,.1)}
    .title{ font-weight:800; letter-spacing:.4px; color:#f3f6ff; text-shadow:0 2px 12px rgba(109,226,255,.25) }
    .stat{ display:flex; align-items:center; gap:8px; padding:6px 10px; border-radius:12px; background:#0e1531; border:1px solid #232c59 }
    .btn{ padding:8px 14px; border-radius:12px; background: linear-gradient(180deg, #1a244f, #121a33); border:1px solid #293773; color:#dce7ff; cursor:pointer; box-shadow: var(--shadow); }
    .btn:hover{ filter: brightness(1.08)}
    .btn:active{ transform: translateY(1px)}

    .wrap{ position:relative; margin-top:12px; display:grid; grid-template-columns: 1fr; gap:12px; }
    canvas{ width:100%; height: 76vh; background: radial-gradient(1600px 800px at 50% -10%, #1b2753, #0f1733 45%, #0b1020); border-radius: var(--radius); border:1px solid rgba(255,255,255,.08); box-shadow: var(--shadow); display:block }

    .overlay{ position:absolute; inset:10px; display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .card{ width:min(680px, 92%); background: linear-gradient(180deg, #121a33, #0c1229); border:1px solid #2a376f; border-radius: 20px; box-shadow: var(--shadow); padding:22px; pointer-events:auto }
    .card h1{ margin:0 0 8px; font-size:28px }
    .card p{ color:#c6d6ff }
    .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap }
    .row > *{ flex: 1 1 auto }
    .select{ appearance:none; padding:10px 12px; border-radius:12px; border:1px solid #31407e; background:#0b1537; color:#e7f0ff; }
    .help-list{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 18px; margin:10px 0 16px }
    .help-list div{ background:#0d1532; border:1px solid #213067; padding:10px 12px; border-radius:12px }
    .kbd{ font-weight:700; padding:2px 8px; border-radius:8px; background:#172251; border:1px solid #2b3a7b; color:#cfe2ff }
    .hide{ display:none }

    .toast{ position:absolute; right:18px; bottom:18px; background:#0c132b; border:1px solid #273267; border-radius:12px; padding:10px 12px; color:#cfe2ff; box-shadow: var(--shadow); }

    .progress{ height:8px; border-radius:10px; background: #0a1437; border:1px solid #20306b; overflow:hidden }
    .progress > div{ height:100%; background: linear-gradient(90deg, #46d4ff, #9cff6d); width:0% }

    @media (max-height: 720px){ canvas{ height: 58vh } }
  </style>
</head>
<body>
  <div id="root">
    <div class="hud">
      <div class="hud-left">
        <div class="title">üç¥ MuncherJS</div>
        <div class="badge" id="categoryBadge">Category: <strong>‚Äì</strong></div>
        <div class="stat">Level <span id="level">1</span></div>
        <div class="stat">Score <span id="score">0</span></div>
        <div class="stat">Lives <span id="lives">3</span></div>
      </div>
      <div class="hud-right row" style="justify-content:flex-end; flex:1 1 auto">
        <button class="btn" id="pauseBtn">‚è∏Ô∏è Pause</button>
        <button class="btn" id="helpBtn">‚ùì Help</button>
      </div>
    </div>

    <div class="wrap">
      <canvas id="game" width="1200" height="800"></canvas>

      <!-- Start Menu -->
      <div id="menu" class="overlay">
        <div class="card">
          <h1>üç¥ MuncherJS</h1>
          <p>Eat tiles that match the category. Avoid the Troggles!</p>
          <div class="row" style="margin:10px 0 6px">
            <label>
              <div style="opacity:.75; font-size:12px">Difficulty</div>
              <select id="difficulty" class="select">
                <option value="easy">Easy</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Hard</option>
              </select>
            </label>
            <label>
              <div style="opacity:.75; font-size:12px">Category</div>
              <select id="categorySelect" class="select"></select>
            </label>
            <label>
              <div style="opacity:.75; font-size:12px">Mode</div>
              <select id="modeSelect" class="select">
                <option value="classic" selected>Classic</option>
                <option value="math">Math</option>
              </select>
            </label>
            <label>
              <div style="opacity:.75; font-size:12px">Grid</div>
              <select id="gridSelect" class="select">
                <option value="10x7">10 √ó 7</option>
                <option value="12x8" selected>12 √ó 8</option>
                <option value="14x9">14 √ó 9</option>
              </select>
            </label>
          </div>
          <div class="progress" title="Level progress"><div id="levelProgress"></div></div>
          <div class="row" style="margin-top:14px">
            <button class="btn" id="startBtn">‚ñ∂Ô∏è Start</button>
            <button class="btn" id="shuffleBtn">üîÄ Random Category</button>
          </div>
          <div style="opacity:.75; font-size:12px; margin-top:10px">Use <span class="kbd">Arrow Keys</span> or <span class="kbd">WASD</span> to move one tile per press; <span class="kbd">Space</span> to munch.</div>
        </div>
      </div>

      <!-- Help -->
      <div id="help" class="overlay hide">
        <div class="card">
          <h1>How to Play</h1>
          <div class="help-list">
            <div><strong>Goal:</strong> Eat all tiles that match the category (shown top‚Äëleft) to clear the level.</div>
            <div><strong>Move:</strong> One tile per key press. No holding.</div>
            <div><strong>Eat:</strong> Press <span class="kbd">Space</span> (or <span class="kbd">Enter</span>) while on a tile.</div>
            <div><strong>Beware:</strong> Troggles step once every 3 seconds.</div>
            <div><strong>Power‚Äëups:</strong> Stars freeze Troggles for ~3.5s.</div>
            <div><strong>Scoring:</strong> +100 correct, ‚àí50 wrong, +500 level bonus.</div>
            <div><strong>Math Mode:</strong> Fill the right meter with correct answers to level up. Each level needs 2√ó more than the last; wrong answers drain the meter. Category changes every level.</div>
          </div>
          <div class="row"><button class="btn" id="closeHelp">Close</button></div>
        </div>
      </div>

      <!-- Game Over -->
      <div id="gameover" class="overlay hide">
        <div class="card">
          <h1>Game Over</h1>
          <p id="finalStats">You scored 0.</p>
          <div class="row">
            <button class="btn" id="againBtn">üîÅ Play Again</button>
            <button class="btn" id="menuBtn">üè† Main Menu</button>
          </div>
        </div>
      </div>

      <div id="toast" class="toast hide"></div>
    </div>
  </div>

  <script>
  // ===== Utility =====
  const rand = (min, max) => Math.random() * (max - min) + min;
  const randi = (min, max) => Math.floor(rand(min, max));
  const choice = arr => arr[Math.floor(Math.random()*arr.length)];
  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
  const now = () => performance.now();
  const shuffle = arr => { for (let i=arr.length-1; i>0; i--){ const j=randi(0,i+1); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr };
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  // Star shape helper (used for powerups and correct-pick effect)
  function drawStar(ctx, cx, cy, spikes, outerR, innerR, color){
    const step = Math.PI / spikes;
    let rot = -Math.PI/2;
    ctx.save();
    ctx.beginPath();
    for(let i=0;i<spikes;i++){
      ctx.lineTo(cx + Math.cos(rot)*outerR, cy + Math.sin(rot)*outerR); rot += step;
      ctx.lineTo(cx + Math.cos(rot)*innerR, cy + Math.sin(rot)*innerR); rot += step;
    }
    ctx.closePath();
    ctx.fillStyle = color; ctx.fill();
    ctx.restore();
  }
  // Star shape helper (used for powerups and correct-pick effect)
  function drawStar(ctx, cx, cy, spikes, outerR, innerR, color){
    const step = Math.PI / spikes;
    let rot = -Math.PI/2;
    ctx.save();
    ctx.beginPath();
    for(let i=0;i<spikes;i++){
      ctx.lineTo(cx + Math.cos(rot)*outerR, cy + Math.sin(rot)*outerR); rot += step;
      ctx.lineTo(cx + Math.cos(rot)*innerR, cy + Math.sin(rot)*innerR); rot += step;
    }
    ctx.closePath();
    ctx.fillStyle = color; ctx.fill();
    ctx.restore();
  }
  // Star shape helper (used for powerups and correct-pick effect)
  function drawStar(ctx, cx, cy, spikes, outerR, innerR, color){
    const step = Math.PI / spikes;
    let rot = -Math.PI/2;
    ctx.save();
    ctx.beginPath();
    for(let i=0;i<spikes;i++){
      ctx.lineTo(cx + Math.cos(rot)*outerR, cy + Math.sin(rot)*outerR); rot += step;
      ctx.lineTo(cx + Math.cos(rot)*innerR, cy + Math.sin(rot)*innerR); rot += step;
    }
    ctx.closePath();
    ctx.fillStyle = color; ctx.fill();
    ctx.restore();
  }
  // Star shape helper (used for powerups and correct-pick effect)
  function drawStar(ctx, cx, cy, spikes, outerR, innerR, color){
    const step = Math.PI / spikes;
    let rot = -Math.PI/2;
    ctx.save();
    ctx.beginPath();
    for(let i=0;i<spikes;i++){
      ctx.lineTo(cx + Math.cos(rot)*outerR, cy + Math.sin(rot)*outerR); rot += step
  const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  const lerp = (a,b,t)=> a + (b-a)*t;
  const lerp = (a,b,t)=> a + (b-a)*t;
  const lerp = (a,b,t)=> a + (b-a)*t;
  const lerp = (a,b,t)=> a + (b-a)*t;
  const lerp = (a,b,t)=> a + (b-a)*t;

  const isPrime = n => {
    if (n<2) return false; if (n%2===0) return n===2; const r=Math.sqrt(n)|0; for(let i=3;i<=r;i+=2){ if(n%i===0) return false } return true;
  };

  // ===== Category generators =====
  const wordSets = {
    fruits:["apple","banana","grape","orange","pear","peach","cherry","mango","kiwi","plum","lemon","lime","apricot","fig","melon"],
    mammals:["dog","cat","whale","bat","human","elephant","tiger","lion","horse","dolphin","mouse","wolf","bear","otter","giraffe"],
    colors:["red","blue","green","yellow","purple","orange","pink","black","white","gray","brown","cyan","magenta"],
    planets:["mercury","venus","earth","mars","jupiter","saturn","uranus","neptune"],
    usStates:["alabama","alaska","arizona","arkansas","california","colorado","connecticut","delaware","florida","georgia","hawaii","idaho","illinois","indiana","iowa","kansas","kentucky","louisiana","maine","maryland","massachusetts","michigan","minnesota","mississippi","missouri","montana","nebraska","nevada","new hampshire","new jersey","new mexico","new york","north carolina","north dakota","ohio","oklahoma","oregon","pennsylvania","rhode island","south carolina","south dakota","tennessee","texas","utah","vermont","virginia","washington","west virginia","wisconsin","wyoming"],
    elements:["hydrogen","helium","lithium","beryllium","boron","carbon","nitrogen","oxygen","fluorine","neon","sodium","magnesium","aluminum","silicon","phosphorus","sulfur","chlorine","argon","potassium","calcium","iron","copper","zinc","silver","gold","tin","lead","mercury"]
  };

  function makeWordCategory(name, correctSet, distractFromKeys, labelCase='lower'){
    const correct = new Set(correctSet);
    const distractPool = Object.keys(wordSets)
      .filter(k=>distractFromKeys.includes(k))
      .flatMap(k=>wordSets[k]);
    const normalize = s => labelCase==='title' ? s.replace(/\b\w/g,c=>c.toUpperCase()) : labelCase==='upper'? s.toUpperCase(): s;
    return {
      id: name.toLowerCase().replace(/\s+/g,'-'),
      name,
      type:'word',
      generate: (W,H,countCorrect=12)=>{
        const selectedCorrect = shuffle([...correct]).slice(0, countCorrect);
        const totalTiles = W*H;
        const distractNeeded = Math.max(0, totalTiles - selectedCorrect.length);
        const distractors = shuffle(distractPool.filter(w=>!correct.has(w))).slice(0, distractNeeded);
        const items = shuffle([...selectedCorrect, ...distractors]).map(w=>({ label: normalize(w), value:w, correct: correct.has(w) }));
        return items;
      }
    };
  }

  function numericCategory(name, predicate, opts={}){
    return {
      id: name.toLowerCase().replace(/\s+/g,'-'),
      name,
      type:'number',
      generate: (W,H)=>{
        const total=W*H; const items=[]; const min=opts.min??2; const max=opts.max??99;
        const pool = Array.from({length:max-min+1},(_,i)=>i+min);
        const chosen = shuffle(pool).slice(0,total);
        for(const n of chosen){ items.push({ label:String(n), value:n, correct: !!predicate(n) }); }
        return shuffle(items);
      }
    };
  }

  const CATEGORIES = [
    numericCategory("Multiples of 3", n=>n%3===0),
    numericCategory("Even Numbers", n=>n%2===0),
    numericCategory("Prime Numbers", n=>isPrime(n), {min:2,max:199}),
    numericCategory("Squares", n=>Number.isInteger(Math.sqrt(n))),
    numericCategory("Factors of 36", n=>36%n===0, {min:1,max:72}),
    numericCategory("Greater than 50", n=>n>50, {min:1,max:99}),
    makeWordCategory("Fruits", wordSets.fruits, ["mammals","colors","planets","elements"], 'lower'),
    makeWordCategory("Mammals", wordSets.mammals, ["fruits","colors","planets","elements"], 'lower'),
    makeWordCategory("Colors", wordSets.colors, ["fruits","mammals","planets","elements"], 'lower'),
    makeWordCategory("Planets", wordSets.planets, ["fruits","mammals","colors","elements"], 'lower'),
    makeWordCategory("US States", wordSets.usStates, ["fruits","mammals","colors","planets"], 'title'),
    makeWordCategory("Chemical Elements", wordSets.elements, ["fruits","mammals","colors","planets"], 'lower')
  ];

  function pickRandomCategory(excludeId){
    const choices = CATEGORIES.filter(c=>c.id!==excludeId);
    return choice(choices.length?choices:CATEGORIES);
  }
  function pickRandomMathCategory(excludeId){
    const nums = CATEGORIES.filter(c=>c.type==='number' && c.id!==excludeId);
    return choice(nums.length?nums:CATEGORIES.filter(c=>c.type==='number'));
  }
  function computeMathNeeded(level, base){
    return Math.max(1, Math.floor(base * Math.pow(2, level-1)));
  }
// ===== Game constants =====
  const DIRS = { UP:0, RIGHT:1, DOWN:2, LEFT:3 };
  const DIR_VECT = [ [0,-1],[1,0],[0,1],[-1,0] ];
  const ENEMY_STEP_MS = 3000; // enemies move one tile every 3s
  const TROGGLE_COLORS = ['#ff3b6b','#ffb800','#00e5ff','#7cff00','#ff00e5','#ff7a00','#00ffb3','#ffd700','#00ffd0','#ff4d00'];

  // ===== Game state =====
  let state = {
    running:false,
    paused:false,
    level:1,
    score:0,
    lives:3,
    gridW:12,
    gridH:8,
    tile:64,
    category: CATEGORIES[0],
    items:[],
    correctRemaining:0,
    player:null,
    enemies:[],
    freezeUntil:0,
    invulnUntil:0,
    lastTime:0,
    mode:'classic',
    math:{progress:0, base:6, needed:6},
  };

  // Explosions store
  let explosions = []; let starBursts = []; let sfx = []; let catFly = null; let starBursts = []; let sfx = []; let catFly = null; let starBursts = []; let sfx = []; let catFly = null; let starBursts = []; let sfx = []; let catFly = null; let starBursts = []; let sfx = []; let catFly = null;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width*dpr);
    canvas.height = Math.floor(rect.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    state.tile = Math.floor(Math.min(rect.width/state.gridW, rect.height/state.gridH));
  }
  addEventListener('resize', resizeCanvas);

  // ===== Board generation =====
  function buildBoard(){
    const W=state.gridW, H=state.gridH;
    const items = state.category.generate(W,H, state.mode==='math' ? Math.min(W*H, Math.max(12, state.math.needed||12)) : undefined);
    const totalCorrect = items.filter(i=>i.correct).length;
    if (totalCorrect < Math.max(6, Math.floor(W*H*0.2))){
      let tries=0;
      while(tries<10){
        const alt = state.category.generate(W,H, state.mode==='math' ? Math.min(W*H, Math.max(12, state.math.needed||12)) : undefined);
        if (alt.filter(i=>i.correct).length>totalCorrect){ items.splice(0, items.length, ...alt); break; }
        tries++;
      }
    }
    state.items = items.map((it, idx)=>({
      ...it,
      eaten:false,
      gx: idx % W,
      gy: Math.floor(idx / W)
    }));
    state.correctRemaining = state.items.filter(t=>t.correct).length;
  }

  // ===== Entities =====
  function spawnPlayer(){
    state.player = { gx:0, gy:0, x:0, y:0, dir:DIRS.RIGHT, moving:null };
  }

  function spawnEnemies(){
    const base = state.level<=3? 2 : state.level<=6? 3 : 4;
    const n = clamp(base + (state.level>6?1:0), 2, 6);
    state.enemies = [];
    const occupied = new Set([`0,0`]);
    const baseTime = now();
    for(let i=0;i<n;i++){
      let ex= randi(0,state.gridW), ey=randi(0,state.gridH), tries=0;
      while( (Math.abs(ex-0)+Math.abs(ey-0)) < Math.floor((state.gridW+state.gridH)/4) || occupied.has(`${ex},${ey}`)){
        ex= randi(0,state.gridW); ey=randi(0,state.gridH); if(++tries>50) break;
      }
      occupied.add(`${ex},${ey}`);
      state.enemies.push({
        gx:ex, gy:ey, x:ex, y:ey,
        dir:randi(0,4),
        color: choice(TROGGLE_COLORS),
        targetBias: rand(0.05, 0.25) + (state.level*0.01),
        nextStepAt: baseTime + ENEMY_STEP_MS + i*150
      });
    }
  }

  // ===== Input =====
  document.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(k)){
      e.preventDefault();
      if(e.repeat) return; // one step per press
      handlePlayerStep(k);
      return;
    }
    if(k===' '|| k==='enter'){ tryEat(); }
    if(k==='p'){ togglePause(); }
    if(k==='escape'){
      if(!help.classList.contains('hide')){
        help.classList.add('hide');
      } else {
        togglePause();
      }
    }
  });

  function handlePlayerStep(k){
    if(!state.running || state.paused || !state.player) return;
    if(state.player.moving) return; // wait for tween to finish
    let dir = null;
    if(k==='arrowup'||k==='w') dir = DIRS.UP;
    else if(k==='arrowright'||k==='d') dir = DIRS.RIGHT;
    else if(k==='arrowdown'||k==='s') dir = DIRS.DOWN;
    else if(k==='arrowleft'||k==='a') dir = DIRS.LEFT;
    if(dir==null) return;
    const [dx,dy] = DIR_VECT[dir];
    const nx = state.player.gx + dx;
    const ny = state.player.gy + dy;
    if(passable(nx,ny)){
      const fromX = state.player.x, fromY = state.player.y;
      state.player.gx = nx; state.player.gy = ny;
      state.player.dir = dir;
      state.player.moving = { fromX, fromY, toX:nx, toY:ny, start: now(), dur: 200 };
    }
  }

  // ===== Game flow =====
  function startGame(){
    state.running=true; state.paused=false; state.level=1; state.score=0; state.lives=3; state.freezeUntil=0; state.invulnUntil=0;
    nextLevel();
  }

  function nextLevel(){
    if(state.mode==='math'){
      const prev = state.category ? state.category.id : null;
      state.category = pickRandomMathCategory(prev);
      state.math.needed = computeMathNeeded(state.level, state.math.base);
      state.math.progress = 0;
    }
    buildBoard();
    spawnPlayer();
    spawnEnemies();
    updateHUD();
    resetEnemyTimers();
    state.invulnUntil = now() + 1200;
  }

  function resetEnemyTimers(){
    const base = now();
    state.enemies.forEach((e,i)=>{ e.nextStepAt = base + ENEMY_STEP_MS + i*150; });
  }

  function levelCleared(){
    state.score += 500;
    state.level += 1;
    nextLevel();
  }

  function loseLife(){
    if (now() < state.invulnUntil) return;
    state.lives -= 1; state.invulnUntil = now() + 1500;
    showToast('Ouch!');
    if(state.lives<=0){ gameOver(); return; }
    state.player.gx=0; state.player.gy=0; state.player.x=0; state.player.y=0; state.player.dir=DIRS.RIGHT;
  }

  function gameOver(){
    state.running=false; state.paused=false;
    doif(tile.correct){
      state.score += 100;
      if(state.mode==='math'){
        state.math.progress = Math.min(state.math.needed, (state.math.progress||0) + 1);
      } else {
        state.correctRemaining -= 1;
      }
      // celebratory star burst on the eaten tile
      spawnStarBurstCell(tile.gx, tile.gy);
      if(Math.random()<0.06){ spawnPowerUp(tile.gx, tile.gy); }
      if(state.mode==='math'){
        if(state.math.progress >= state.math.needed){ setTimeout(levelCleared, 350); }
      } else {
        if(state.correctRemaining<=0){ setTimeout(levelCleared, 350); }
      }
      showToast('Yum! +100'); state.player.gy);
    if(!tile || tile.eaten) return;
    tile.eaten = true;
    if(tile.correct){
      state.score += 100;
      if(state.mode==='math'){
        state.math.progress = Math.min(state.math.needed, (state.math.progress||0) + 1);
      } else {
        state.correctRemaining -= 1;
      }
      // celebratory star burst on the eaten tile
      spawnStarBurstCell(tile.gx, tile.gy);
      if(Math.random()<0.06){ spawnPowerUp(tile.gx, tile.gy); }
      if(state.mode==='math'){
        if(state.math.progress >= state.math.n} else {
      state.score = Math.max(0, state.score - 50);
      // anime disappointment above the player
      spawnDisappointAt(state.player.gx, state.player.gy);     if(state.correctRemaining
    } else {
      state.score = Math.max(0, state.score - 50);
      if(state.mode==='math'){
        state.math.progress = Math.max(0, (state.math.progress||0) - 1);
      }
      loseLife();
      showToast('Wrong! ‚àí50');
    }
    updateHUD();
  }

  // ===== Power ups =====
  let star = null; // {gx,gy,active:true}
  function spawnPowerUp(gx,gy){ star = {gx,gy,active:true, born: now()}; }

  // ===== Helpers =====
  function getTileAt(gx,gy){ return state.items.find(t=>t.gx===gx && t.gy===gy); }
  function passable(gx,gy){ return gx>=0 && gy>=0 && gx<state.gridW && gy<state.gridH; }

  // ===== Rendering =====
  function draw(){
    const rect = canvas.getBoundingClientRect();
    const barArea = state.mode==='math' ? Math.max(90, rect.width*0.08) : 0;
    const tile = Math.min((rect.width - barArea)/state.gridW, rect.height/state.gridH);
    const padX = (rect.width - barArea - state.gridW*tile)/2;
    const padY = (rect.height - state.gridH*tile)/2;

    ctx.clearRect(0,0,canvas.width, canvas.height);

    // Update player tween position
    if(state.player && state.player.moving){
      const m = state.player.moving;
      const t = (now()-m.start)/m.dur;
      if(t>=1){
        state.player.x = m.toX; state.player.y = m.toY; state.player.moving = null;
      } else {
        const s = easeOutCubic(Math.max(0, Math.min(1, t)));
        state.player.x = m.fromX + (m.toX - m.fromX)*s;
        state.player.y = m.fromY + (m.toY - m.fromY)*s;
      }
    }

    // Grid / tiles
    for(const t of state.items){
      const x = padX + t.gx*tile; const y = padY + t.gy*tile; const r = 14;
      ctx.beginPath();
      roundRect(ctx, x+2, y+2, tile-4, tile-4, r);
      const grad = ctx.createLinearGradient(x,y,x+tile,y+tile);
      grad.addColorStop(0, t.eaten? '#0c1430' : '#15204a');
      grad.addColorStop(1, t.eaten? '#0a1126' : '#0e1737');
      ctx.fillStyle = grad; ctx.fill();
      ctx.strokeStyle = t.eaten? 'rgba(255,255,255,.06)' : 'rgba(255,255,255,.12)';
      ctx.lineWidth = 1.2; ctx.stroke();

      if(!t.eaten){
        // Wrapped text inside the tile
        ctx.save();
        ctx.fillStyle = 'rgba(230,240,255,.95)';
        const fontSize = Math.floor(tile*0.23);
        ctx.font = `${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const maxWidth = tile*0.82;
        const lineHeight = Math.max(16, Math.floor(fontSize*1.05));
        const lines = wrapLabel(t.label, maxWidth, ctx, 3);
        const totalH = lines.length * lineHeight;
        let ly = y + tile/2 - totalH/2 + lineHeight/2;
        for(const line of lines){ ctx.fillText(line, x+tile/2, ly); ly += lineHeight; }
        ctx.restore();
      } else if (t.correct){
        ctx.save();
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = '#9cff6d';
        ctx.beginPath(); ctx.arc(x+tile/2, y+tile/2, tile*0.18, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    // Star powerup
    if(star && star.active){
      const x = padX + star.gx*tile + tile/2; const y = padY + star.gy*tile + tile/2;
      drawStar(ctx, x, y, 5, tile*0.22, tile*0.09, '#ffd166');
    }

    // Player
    if(state.player){
      const px = padX + state.player.x*tile + tile/2;
      const py = padY + state.player.y*tile + tile/2;
      const inv = now()<state.invulnUntil;
      const panim = getPlayerAnim();
      drawMuncher(ctx, px, py, tile*0.34, state.player.dir, inv, panim);
    }

    // Enemies
    for(const e of state.enemies){
      const ex = padX + e.x*tile + tile/2; const ey = padY + e.y*tile + tile/2;
      const frozen = now()<state.freezeUntil;
      drawTroggle(ctx, ex, ey,drawExplosions(ctx, padX, padY, tile);
    drawStarBursts(ctx, padX, padY, tile);
    drawSFX(ctx, padX, padY, tile);

    if(state.mode==='mat// Explosions overlay
    drawExplosions(ctx, padX, padY, tile);

    if(state.mode==='math'){
      drawLevelBar(ctx, rect, barArea);
    }
  }

  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr);
  }

  // Wrapped text helper (avoid regex escapes in canvas tool)
  function wrapLabel(text, maxWidth, ctx, maxLines=3){
    const words = String(text).split(' ');
    const lines = [];
    let line = '';
    for(let w of words){
      const test = line ? line + ' ' + w : w;
      if(ctx.measureText(test).width <= maxWidth){
        line = test;
      } else {
        if(line){ lines.push(line); if(lines.length>=maxLines) return lines; }
        // Hard-break very long single words
        let tmp = w;
        while(ctx.measureText(tmp).width > maxWidth){
          let cut = tmp.length;
          while(cut>1 && ctx.measureText(tmp.slice(0,cut)).width>maxWidth) cut--;
          lines.push(tmp.slice(0,cut));
          tmp = tmp.slice(cut);
          if(lines.length>=maxLines) return lines;
        }
        line = tmp;
      }
    }
    if(line && lines.length<maxLines) lines.push(line);
    return lines;
  }

  // Star shape helper (used for powerups and correct-pick effect)
  function drawStar(ctx, cx, cy, spikes, outerR, innerR, color){
    const step = Math.PI / spikes;
    let rot = -Math.PI/2;
    ctx.save();
    ctx.beginPath();
    for(let i=0;i<spikes;i++){
      ctx.lineTo(cx + Math.cos(rot)*outerR, cy(){
    const p = state.player; if(!p) return {moving:false, phase:0, tilt:0, yOffset:0, cape:0};
    const moving = !!p.moving;
    const phase = moving ? clamp((now()-p.moving.start)/p.moving.dur, 0, 1) : 0;
    let tilt = 0, yOffset = 0, cape = 0;
    if(moving){
      if(p.dir===DIRS.DOWN){
        // jump arc while moving down
        yOffset = -Math.sin(Math.PI*phase)*0.45; // up then land
        tilt = -0.15 + 0.1*Math.sin(Math.PI*phase);
        cape = 0.4;
      } else {
        // flying lean & slight bob
        tilt = 0.25*(1-Math.cos(Math.PI*phase));
        yOffset = -Math.sin(Math.PI*phase)*0.18;
        cape = 1.0;
      }
    } else {
      cape = 0.3;
    }
    return {moving, phase, tilt, yOffset, cape};
  }

  function drawMuncher(ctx, x,y, radius, dir, invuln, anim={}){
    const angle = [ -Math.PI/2, 0, Math.PI/2, Math.PI ][dir];
    ctx.save();
    ctx.translate(x,y); ctx.rotate(angle);

    // flight/jump animation transforms
    const tilt = anim.tilt || 0;
    const yShift = (anim.yOffset||0) * radius;
    ctx.rotate(tilt);
    ctx.translate(0, yShift);

    const bodyW = radius*1.05;
    const bodyH = radius*1.7;

    // ---- Cape (behind) ‚Äî green ----
    ctx.save();
    ctx.shadowColor = '#34d399';
    ctx.shadowBlur = 14;
    ctx.beginPath();
    const cx0 = -bodyW*0.55, cy0 = -bodyH*0.3;
    const wiggle = (anim.cape?1:0) * Math.sin(now()/130 + (anim.phase||0)*3) * bodyH*0.12;
    ctx.moveTo(cx0, cy0);
    ctx.bezierCurveTo(-bodyW*1.2, cy0 + bodyH*0.2 + wiggle*0.2, -bodyW*0.8, cy0 + bodyH*0.9 + wiggle, -bodyW*0.1, cy0 + bodyH*0.8 + wiggle*0.6);
    ctx.bezierCurveTo(bodyW*0.3, cy0 + bodyH*0.7 + wiggle*0.2, bodyW*0.5, cy0 + bodyH*0.1 + wiggle*0.1, bodyW*0.1, cy0 + bodyH*0.05 + wiggle*0.05);
    ctx.closePath();
    const capeGrad = ctx.createLinearGradient(cx0, cy0, bodyW*0.2, cy0+bodyH*0.8);
    capeGrad.addColorStop(0, '#34d399');
    capeGrad.addColorStop(1, '#059669');
    ctx.fillStyle = capeGrad; ctx.fill();
    ctx.restore();

    // ---- Torso (green suit) ----
    const torsoX = -bodyW/2, torsoY = -bodyH*0.55, torsoW = bodyW, torsoH = bodyH*1.05;
    const torsoGrad = ctx.createLinearGradient(0, torsoY, 0, torsoY+torsoH);
    torsoGrad.addColorStop(0, '#4ade80');
    torsoGrad.addColorStop(1, '#065f46');
    ctx.beginPath();
    ctx.fillStyle = torsoGrad;
    roundRect(ctx, torsoX, torsoY, torsoW, torsoH, 12); ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.lineWidth=1.5; ctx.stroke();

    // ---- Belt ----
    ctx.fillStyle = '#9cff6d';
    ctx.fillRect(torsoX+4, -bodyH*0.02, torsoW-8, radius*0.18);

    // ---- Emblem (M) ----
    const emX = 0, emY = -bodyH*0.1;
    ctx.beginPath();
    ctx.moveTo(emX, emY - radius*0.18);
    ctx.lineTo(emX + radius*0.16, emY);
    ctx.lineTo(emX, emY + radius*0.18);
    ctx.lineTo(emX - radius*0.16, emY);
    ctx.closePath();
    ctx.fillStyle = '#0f5132'; ctx.fill();
    ctx.fillStyle = '#9cff6d';
    ctx.font = `${Math.max(10, Math.floor(radius*0.34))}px ui-sans-serif, system-ui`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('M', emX, emY+1);

    // ---- Moose Head ----
    const headR = radius*0.45; const hx = 0, hy = -bodyH*0.95;
    ctx.fillStyle = '#8b5e34';
    ctx.beginPath(); ctx.arc(hx, hy, headR, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#c79a67';
    ctx.beginPath(); ctx.ellipse(hx, hy + headR*0.25, headR*0.9, headR*0.55, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#231f20';
    ctx.beginPath(); ctx.arc(hx - headR*0.18, hy + headR*0.28, headR*0.08, 0, Math.PI*2);
    ctx.arc(hx + headR*0.18, hy + headR*0.28, headR*0.08, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff';
    ctx.beginPath(); ctx.arc(hx - headR*0.28, hy - headR*0.15, headR*0.12, 0, Math.PI*2); ctx.arc(hx + headR*0.28, hy - headR*0.15, headR*0.12, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#0b1020';
    ctx.beginPath(); ctx.arc(hx - headR*0.28, hy - headR*0.15, headR*0.06, 0, Math.PI*2); ctx.arc(hx + headR*0.28, hy - headR*0.15, headR*0.06, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#8b5e34';
    ctx.beginPath();
    ctx.moveTo(hx - headR*0.65, hy - headR*0.2);
    ctx.quadraticCurveTo(hx - headR*0.8, hy - headR*0.55, hx - headR*0.4, hy - headR*0.45);
    ctx.quadraticCurveTo(hx - headR*0.55, hy - headR*0.25, hx - headR*0.65, hy - headR*0.2); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(hx + headR*0.65, hy - headR*0.2);
    ctx.quadraticCurveTo(hx + headR*0.8, hy - headR*0.55, hx + headR*0.4, hy - headR*0.45);
    ctx.quadraticCurveTo(hx + headR*0.55, hy - headR*0.25, hx + headR*0.65, hy - headR*0.2); ctx.fill();
    const antler = (side)=>{
      const s = side===-1? -1: 1;
      ctx.save();
      ctx.translate(hx + s*headR*0.2, hy - headR*0.65);
      ctx.scale(s,1);
      ctx.fillStyle = '#e9d8a6';
      ctx.strokeStyle = 'rgba(0,0,0,.2)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.bezierCurveTo(headR*0.4, -headR*0.2, headR*0.8, -headR*0.6, headR*1.1, -headR*0.7);
      ctx.bezierCurveTo(headR*0.9, -headR*0.4, headR*0.9, -headR*0.2, headR*0.7, -headR*0.05);
      ctx.bezierCurveTo(headR*0.8, -headR*0.05, headR*0.9, -headR*0.02, headR*1.0, 0);
      ctx.bezierCurveTo(headR*0.8, headR*0.05, headR*0.4, headR*0.05, 0, 0);
      ctx.closePath(); ctx.fill(); ctx.stroke();
      const tine = (tx,ty,len)=>{ ctx.beginPath(); ctx.moveTo(tx,ty); ctx.lineTo(tx+len, ty - headR*0.18); ctx.lineWidth=1.3; ctx.stroke(); };
      tine(headR*0.45, -headR*0.35, headR*0.35);
      tine(headR*0.65, -headR*0.5, headR*0.3);
      tine(headR*0.85, -headR*0.6, headR*0.25);
      ctx.restore();
    };
    antler(-1); antler(1);

    ctx.strokeStyle='#e6f0ff';
    ctx.lineWidth = Math.max(2, radius*0.12);
    ctx.lineCap='round';
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.45, -bodyH*0.25); ctx.lineTo(-bodyW*0.85, -bodyH*0.05);
    ctx.moveTo(bodyW*0.45, -bodyH*0.25); ctx.lineTo(bodyW*0.85, 0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-bodyW*0.25, bodyH*0.4); ctx.lineTo(-bodyW*0.25, bodyH*0.8);
    ctx.moveTo(bodyW*0.25, bodyH*0.4); ctx.lineTo(bodyW*0.25, bodyH*0.8);
    ctx.stroke();

    if(invuln){
      ctx.globalAlpha=0.6; ctx.strokeStyle='#9cff6d'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(0, -bodyH*0.2, radius*1.1, 0, Math.PI*2); ctx.stroke();
    }

    ctx.restore();
  }

  function drawTroggle(ctx, x,y, size, dir, color, frozen){
    ctx.save(); ctx.translate(x,y); ctx.rotate([ -Math.PI/2, 0, Math.PI/2, Math.PI ][dir]);
    const w=size*1.1, h=size*0.9;

    ctx.shadowColor = color;
    ctx.shadowBlur = frozen? 8 : 18;
    ctx.beginPath();
    ctx.moveTo(-w/2, h/2); ctx.lineTo(0, -h/2); ctx.lineTo(w/2, h/2); ctx.closePath();
    const grd = ctx.createLinearGradient(-w/2,-h/2, w/2,h/2);
    grd.addColorStop(0, frozen? '#8af1ff' : color);
    grd.addColorStop(1, '#ffffff22');
    ctx.fillStyle = grd; ctx.fill();
    ctx.shadowBlur = 0;
    ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(-size*0.2, -size*0.06, size*0.09, 0, Math.PI*2); ctx.arc(size*0.2, -size*0.06, size*0.09, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#0b1020'; ctx.beginPath(); ctx.arc(-size*0.2, -size*0.06, size*0.045, 0, Math.PI*2); ctx.arc(size*0.2, -size*0.06, size*0.045, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.moveTo(-w*0.32, h*0.15); ctx.lineTo(w*0.32, h*0.15); ctx.stroke();
    ctx.restore();
  }

  // ===== Right-side Math Level Bar =====
  function drawLevelBar(ctx, rect, barArea){
    const barW = Math.max(20, Math.floor(barArea*0.5));
    const margin = 16;
    const x = rect.width - barArea + (barArea - barW)/2;
    const y = margin;
    cfunction drawExplosions(ctx, padX, padY, tile){
    const tnow = now();
    explosions = explosions.filter(ex => tnow - ex.born < ex.duration);
    for(const ex of explosions){
      const p = clamp((tnow - ex.born)/ex.duration, 0, 1);
      const centerX = padX + ex.gx*tile + tile/2;
      const centerY = padY + ex.gy*tile + tile/2;
      // flash ring
      ctx.save();
      ctx.globalAlpha = 0.5*(1-p);
      ctx.beginPath(); ctx.arc(centerX, centerY, tile*0.15 + tile*0.4*easeOutCubic(p), 0, Math.PI*2); ctx.strokeStyle = '#ff6d8a'; ctx.lineWidth = 2; ctx.stroke();
      ctx.restore();
      // particles
      for(const prt of ex.parts){
        const dist = easeOutCubic(p) * prt.spd * tile * 0.9;
        const x = centerX + Math.cos(prt.ang)*dist;
        const y = centerY + Math.sin(prt.ang)*dist;
        ctx.save();
        ctx.globalAlpha = 1-p;
        ctx.fillStyle = '#ff6d8a';
        ctx.beginPath(); ctx.arc(x, y, Math.max(1.5, 3*(1-p)), 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }
  }

  // ===== Correct pick: star burst =====
  function spawnStarBurstCell(gx,gy){
    const N = 12;
    const parts = [];
    for(let i=0;i<N;i++) parts.push({ ang: rand(0, Math.PI*2), spd: rand(0.6, 1.1) });
    starBursts.push({ gx, gy, born: now(), duration: 700, parts });
  }
  function drawStarBursts(ctx, padX, padY, tile){
    const tnow = now();
    starBursts = starBursts.filter(s => tnow - s.born < s.duration);
    for(const sb of starBursts){
      const p = clamp((tnow - sb.born)/sb.duration, 0, 1);
      const cx = padX + sb.gx*tile + tile/2;
      const cy = padY + sb.gy*tile + tile/2;
      for(const pr of sb.parts){
        const dist = easeOutCubic(p) * pr.spd * tile * 0.95;
        const x = cx + Math.cos(pr.ang)*dist;
        const y = cy + Math.sin(pr.ang)*dist;
        ctx.save(); ctx.globalAlpha = 1-p;
        drawStar(ctx, x, y, 5, Math.max(2, tile*0.10*(1-p)), Math.max(1, tile*0.05*(1-p)), '#ffd166');
        ctx.restore();
      }
    }
  }

  // ===== Wrong pick: anime "disappointed" effect =====
  function spawnDisappointAt(gx,gy){ sfx.push({ type:'disappoint', gx, gy, born: now(), duration: 800 }); }
  function drawSFX(ctx, padX, padY, tile){
    const tnow = now();
    sfx = sfx.filter(e => tnow - e.born < e.duration);
    for(const e of sfx){
      if(e.type==='disappoint'){
        const p = clamp((tnow - e.born)/e.duration, 0, 1);
        const cx = padX + e.gx*tile + tile/2;
        const cy = padY + e.gy*tile + tile/2 - tile*0.2;
        // vertical blue stress lines
        ctx.save(); ctx.strokeStyle = 'rgba(70,212,255,0.9)'; ctx.lineWidth = 2;
        const n=4; for(let i=0;i<n;i++){
          const off = (i - (n-1)/2) * tile*0.08;
          const len = tile*0.22 * (1 - p);
          ctx.beginPath(); ctx.moveTo(cx + off, cy - tile*0.2); ctx.lineTo(cx + off, cy - tile*0.2 + len); ctx.stroke();
        }
        ctx.restore();
        // little sweat drop
        ctx.save(); ctx.globalAlpha = 1-p; ctx.fillStyle = '#46d4ff';
        ctx.beginPath();
        ctx.moveTo(cx + tile*0.18, cy - tile*0.06);
        ctx.quadraticCurveTo(cx + tile*0.24, cy + tile*0.02, cx + tile*0.14, cy + tile*0.10);
        ctx.quadraticCurveTo(cx + tile*0.28, cy + tile*0.00, cx + tile*0.18, cy - tile*0.06);
        ctx.fill(); ctx.restore();
      }
    }
  }

  // ===== Math mode: fly-in category title =====
  function launchCategoryFly(){ catFly = { text: state.category.name, start: now(), delay: 1000, dur: 900 }; }
  function getBadgeCenterInCanvas(){
    const br = catBadge.getBoundingClientRect();
    const cr = canvas.getBoundingClientRect();
    return { x: br.left - cr.left + br.width/2, y: br.top - cr.top + br.height/2 };
  }
  function drawCategoryFly(ctx, rect){
    if(!catFly) return;
    const elapsed = now() - catFly.start;
    const from = { x: rect.width/2, y: rect.height*0.42 };
    const to = getBadgeCenterInCanvas();
    if(elapsed < catFly.delay){
      ctx.save(); ctx.globalAlpha = 0.95; ctx.fillStyle = '#e8f4ff';
      ctx.font = '700 36px system-ui, -apple-system, Segoe UI';
      ctx.textAlign='center'; ctx.textBaseline='middle';
